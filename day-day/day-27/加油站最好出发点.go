// @Author: Ciusyan 12/16/23

package day_27

/**
给定一个 gas 数组和一个 cost 数组，比如：
gas:  [2, 1, 1, 3] ，代表 0 号加油站有 2 的油，1 号加油站有 1 的油，2 号加油站有 1 的油，3 号加油站有 3 的油。
cost: [2, 2, 1, 2]，代表从 0 -> 1 需要花费 2 的油，从 1 -> 2 需要花费 2 的油，从 2 -> 3 需要花费 1 的油，从 3 -> 0 需要花费 2 的油。
求解从每一个加油站出发，能转完一圈？
比如上面从 0 号加油站出发，先加 2 的油，刚好够跑到 1 号加油站，然后加 1 的油，此时邮箱的油不够跑到 2 加油站了。不能转完一圈
从 1 号加油站出发，先加 1 的油，也不够跑到 2 号加油站。不能转完一圈
从 2 号加油站出发，先加 1 的油，刚好够跑到 3 号加油站，再加 3 的油，从 3 号加油站跑到 0 号加油站后，还剩 1 的油，再加 2 的油，总共还剩 3 的油，够跑到 1 号，到一号加油后，也够跑到 2 号。所以能转完一圈。
从 3 号加油站，先加 3 的油，... 也能跑完一圈
所以最终返回：[false, false, true, true]
*/

func gasStation(gas, cost []int) []bool {
	// 这个题本质上就是：从 i 位置出发，看看跑某一个加油站时，油是否会掉到 0 以下。
	// 所以我们先简化一下这两个数组，gas[i] - cost[i]，代表从 i 位置出发到下一个加油站的情况。
	n := len(gas)
	m := n << 1 // 因为是环形路线，所以为了之后能够从任何一个位置出发，转完一圈，所以补充一倍的状态
	status := make([]int, m)
	for i := 0; i < n; i++ {
		status[i] = gas[i] - cost[i]
		status[i+n] = gas[i] - cost[i]
	}
	// 如何看从 i 位置出发，能否转完一圈呢？先将所有位置累加起来。
	for i := 1; i < m; i++ {
		status[i] += status[i-1]
	}
	// 我们可以看其中最薄弱的位置，如果它原始的累加和都没有掉到 0 以下，那么肯定可以转完一圈
	// 比如：status [0, -1, 0, 1, 0, -1, 0, 1] 累加后-> [0, -1, -1, 0, 0, -1, -1, 0]
	// 那么如果从 i = 2 出发，它最薄弱的地方是 -1，如果最薄弱的地方原始的累加和是不小于 0 的，就可以。
	// 如果求解原始的累加和呢？可以利用所有的累加和数组，减去前缀，就能得到最薄弱位置最原始的累加和：-1 - status[i-1] = 0
	// 即 i = 2 出发，最薄弱的地方都不会小于0，所以可以转完一圈。

	// 那么我们如何找到最薄弱的地方呢？可以利用滑动窗口来更新最小值
	minQueue := NewDoubleQueue()
	// 先将窗口建立起来，窗口的长度固定为 n
	for i := 0; i < n; i++ {
		for minQueue.Size() != 0 && status[i] <= status[minQueue.GetRight()] {
			// 说明即将要加入的元素太大了，要腾出位置，否则队列就不满足从小到大的顺序了
			minQueue.PollRight()
		}
		// 到达这里后，可以安全的加入了，记得放的是索引
		minQueue.OfferRight(i)
	}

	// 有了这个窗口，minQueue 中最左侧的值就是这个窗口中最薄弱的位置
	var (
		// 代表前缀，第一个窗口没有前缀，默认为 0
		prefix = 0
		// 窗口的左边界，用于判断窗口维护的最小值是否有效
		l = 0
		// 窗口的右边界，因为已经求解了第一个窗口了
		r = n
	)

	res := make([]bool, n)
	// 窗口右边界不能越界
	for r < m {
		if status[minQueue.GetLeft()]-prefix >= 0 {
			// 说明此时窗口内最薄弱的地方的累加没有掉到 0 以下，可以跑完一圈
			res[l] = true
		}

		// 需要滑动窗口了，将窗口往后滑动一个单位
		for minQueue.Size() != 0 && status[r] <= status[minQueue.GetRight()] {
			// 要保证添加进入窗口后，维持从小到大的顺序
			minQueue.PollRight()
		}
		minQueue.OfferRight(r)

		// 还要看看窗口维护的最小值，有没有失效（是否已经滑出窗口了）
		if minQueue.GetLeft() == l {
			// 说明马上就要滑出窗口了
			minQueue.PollLeft()
		}

		// 更新窗口边界、前缀
		prefix = status[l]
		l++
		r++
	}

	return res
}
